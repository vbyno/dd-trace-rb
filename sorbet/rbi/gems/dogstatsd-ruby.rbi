# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dogstatsd-ruby/all/dogstatsd-ruby.rbi
#
# dogstatsd-ruby-5.2.0

module Datadog
end
class Datadog::Statsd
  def batch; end
  def close(flush: nil); end
  def count(stat, count, opts = nil); end
  def decrement(stat, opts = nil); end
  def distribution(stat, value, opts = nil); end
  def event(title, text, opts = nil); end
  def flush(flush_telemetry: nil, sync: nil); end
  def forwarder; end
  def gauge(stat, value, opts = nil); end
  def histogram(stat, value, opts = nil); end
  def host; end
  def increment(stat, opts = nil); end
  def initialize(host = nil, port = nil, socket_path: nil, namespace: nil, tags: nil, sample_rate: nil, buffer_max_payload_size: nil, buffer_max_pool_size: nil, buffer_overflowing_stategy: nil, logger: nil, single_thread: nil, telemetry_enable: nil, telemetry_flush_interval: nil); end
  def namespace; end
  def now; end
  def port; end
  def sample_rate; end
  def self.open(*args); end
  def send_stats(stat, delta, type, opts = nil); end
  def serializer; end
  def service_check(name, status, opts = nil); end
  def set(stat, value, opts = nil); end
  def socket_path; end
  def sync_with_outbound_io; end
  def tags; end
  def telemetry; end
  def time(stat, opts = nil); end
  def timing(stat, ms, opts = nil); end
  def transport_type; end
end
class Datadog::Statsd::Connection
  def close; end
  def initialize(telemetry: nil, logger: nil); end
  def logger; end
  def socket; end
  def telemetry; end
  def write(payload); end
end
class Datadog::Statsd::Telemetry
  def bytes_dropped; end
  def bytes_sent; end
  def dropped(bytes: nil, packets: nil); end
  def events; end
  def flush; end
  def initialize(flush_interval, global_tags: nil, transport_type: nil); end
  def metrics; end
  def now_in_s; end
  def packets_dropped; end
  def packets_sent; end
  def pattern; end
  def reset; end
  def sent(metrics: nil, events: nil, service_checks: nil, bytes: nil, packets: nil); end
  def serialized_tags; end
  def service_checks; end
  def should_flush?; end
  def would_fit_in?(max_buffer_payload_size); end
end
class Datadog::Statsd::UDPConnection < Datadog::Statsd::Connection
  def connect; end
  def host; end
  def initialize(host, port, **kwargs); end
  def port; end
  def send_message(message); end
end
class Datadog::Statsd::UDSConnection < Datadog::Statsd::Connection
  def connect; end
  def initialize(socket_path, **kwargs); end
  def send_message(message); end
  def socket_path; end
end
class Datadog::Statsd::UDSConnection::BadSocketError < StandardError
end
class Datadog::Statsd::MessageBuffer
  def add(message); end
  def buffer; end
  def bytesize_threshold; end
  def connection; end
  def ensure_sendable!(message_size); end
  def flush; end
  def initialize(connection, max_payload_size: nil, max_pool_size: nil, overflowing_stategy: nil); end
  def max_payload_size; end
  def max_pool_size; end
  def overflowing_stategy; end
  def preemptive_flush?; end
  def should_flush?(message_size); end
end
module Datadog::Statsd::Serialization
end
class Datadog::Statsd::Serialization::TagSerializer
  def dd_tags(env = nil); end
  def default_tags(env = nil); end
  def escape_tag_content(tag); end
  def format(message_tags); end
  def global_tags; end
  def initialize(global_tags = nil, env = nil); end
  def to_tags_hash(tags); end
  def to_tags_list(tags); end
end
class Datadog::Statsd::Serialization::ServiceCheckSerializer
  def escape_message(message); end
  def format(name, status, options = nil); end
  def initialize(global_tags: nil); end
  def tag_serializer; end
end
class Datadog::Statsd::Serialization::EventSerializer
  def escape(text); end
  def format(title, text, options = nil); end
  def initialize(global_tags: nil); end
  def tag_serializer; end
end
class Datadog::Statsd::Serialization::StatSerializer
  def format(name, delta, type, tags: nil, sample_rate: nil); end
  def formated_name(name); end
  def global_tags; end
  def initialize(prefix, global_tags: nil); end
  def prefix; end
  def tag_serializer; end
end
class Datadog::Statsd::Serialization::Serializer
  def event_serializer; end
  def global_tags; end
  def initialize(prefix: nil, global_tags: nil); end
  def service_check_serializer; end
  def stat_serializer; end
  def to_event(title, text, options = nil); end
  def to_service_check(name, status, options = nil); end
  def to_stat(name, delta, type, tags: nil, sample_rate: nil); end
end
class Datadog::Statsd::Sender
  def add(message); end
  def flush(sync: nil); end
  def initialize(message_buffer); end
  def message_buffer; end
  def message_queue; end
  def rendez_vous; end
  def send_loop; end
  def sender_thread; end
  def start; end
  def stop(join_worker: nil); end
end
class Datadog::Statsd::SingleThreadSender
  def add(message); end
  def flush(*arg0); end
  def initialize(message_buffer); end
  def rendez_vous; end
  def start; end
  def stop; end
end
class Datadog::Statsd::Forwarder
  def buffer; end
  def close; end
  def connection; end
  def do_flush_telemetry; end
  def flush(flush_telemetry: nil, sync: nil); end
  def host; end
  def initialize(host: nil, port: nil, socket_path: nil, buffer_max_payload_size: nil, buffer_max_pool_size: nil, buffer_overflowing_stategy: nil, telemetry_flush_interval: nil, global_tags: nil, single_thread: nil, logger: nil); end
  def port; end
  def send_message(message); end
  def sender; end
  def socket_path; end
  def sync_with_outbound_io; end
  def telemetry; end
  def tick_telemetry; end
  def transport_type; end
end
class Datadog::Statsd::Error < StandardError
end
